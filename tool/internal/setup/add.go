// Copyright The OpenTelemetry Authors
// SPDX-License-Identifier: Apache-2.0

package setup

import (
	"fmt"
	"maps"
	"path/filepath"
	"slices"

	"github.com/dave/dst"

	"github.com/open-telemetry/opentelemetry-go-compile-instrumentation/tool/internal/ast"
	"github.com/open-telemetry/opentelemetry-go-compile-instrumentation/tool/internal/rule"
)

const (
	OtelRuntimeFile = "otel.runtime.go"
)

//nolint:gochecknoglobals // This is a constant
var requiredImports = map[string]string{
	"runtime/debug": "_otel_debug", // The getstack function depends on runtime/debug
	"log":           "_otel_log",   // The printstack function depends on log
	"unsafe":        "_",           // The golinkname tag depends on unsafe
}

// hookImportAliases maps hook module paths to their import aliases.
// This is used to generate named imports for hook functions.
//
//nolint:gochecknoglobals // module-level state for import generation
var hookImportAliases = map[string]string{}

func genImportDecl(matched []*rule.InstFuncRule) []dst.Decl {
	// Create a copy of requiredImports to avoid modifying the global
	allImports := make(map[string]string)
	for k, v := range requiredImports {
		allImports[k] = v
	}
	// Add hook imports with named aliases (not blank imports)
	// This ensures the hook functions are linked into the binary
	for i, m := range matched {
		if _, exists := allImports[m.Path]; !exists {
			alias := fmt.Sprintf("_otel_hook_%d", i)
			allImports[m.Path] = alias
			hookImportAliases[m.Path] = alias
		}
	}
	importDecls := make([]dst.Decl, 0, len(allImports))
	// Sort the keys to ensure deterministic order
	for _, k := range slices.Sorted(maps.Keys(allImports)) {
		importDecls = append(importDecls, ast.ImportDecl(allImports[k], k))
	}
	return importDecls
}

func genVarDecl(matched []*rule.InstFuncRule) []dst.Decl {
	decls := make([]dst.Decl, 0, len(matched))
	uniquePath := map[string]bool{}
	for i, m := range matched {
		if _, ok := uniquePath[m.Path]; ok {
			continue
		}
		uniquePath[m.Path] = true
		// First variable declaration
		// //go:linkname _getstatck%d %s.OtelGetStackImpl
		// var _getstatck%d = _otel_debug.Stack
		value := ast.SelectorExpr(ast.Ident("_otel_debug"), "Stack")
		getStackVar := ast.VarDecl(fmt.Sprintf("_getstatck%d", i), value)
		getStackVar.Decs = dst.GenDeclDecorations{
			NodeDecs: ast.LineComments(
				fmt.Sprintf("//go:linkname _getstatck%d %s.OtelGetStackImpl", i, m.Path)),
		}
		// Second variable declaration
		// //go:linkname _printstack%d %s.OtelPrintStackImpl
		// var _printstack%d = func (bt []byte){ _otel_log.Printf(string(bt)) }
		// Build: string(bt)
		stringCall := &dst.CallExpr{
			Fun:  ast.Ident("string"),
			Args: []dst.Expr{ast.Ident("bt")},
		}
		// Build: _otel_log.Printf(string(bt))
		printfCall := &dst.CallExpr{
			Fun:  ast.SelectorExpr(ast.Ident("_otel_log"), "Printf"),
			Args: []dst.Expr{stringCall},
		}
		// Build: func (bt []byte) { _otel_log.Printf(string(bt)) }
		printStackFunc := &dst.FuncLit{
			Type: &dst.FuncType{
				Params: &dst.FieldList{
					List: []*dst.Field{
						ast.Field("bt", ast.ArrayType(ast.Ident("byte"))),
					},
				},
			},
			Body: ast.BlockStmts(ast.ExprStmt(printfCall)),
		}
		printStackVar := ast.VarDecl(fmt.Sprintf("_printstack%d", i), printStackFunc)
		printStackVar.Decs = dst.GenDeclDecorations{
			NodeDecs: ast.LineComments(
				fmt.Sprintf("//go:linkname _printstack%d %s.OtelPrintStackImpl", i, m.Path)),
		}
		decls = append(decls, getStackVar, printStackVar)
	}
	return decls
}

// genHookRefDecl generates variable declarations that reference the hook functions.
// This ensures the linker includes these symbols in the final binary.
// Example: var _ = _otel_hook_0.BeforeServe
func genHookRefDecl(matched []*rule.InstFuncRule) []dst.Decl {
	decls := make([]dst.Decl, 0, len(matched))
	// Track unique hook references to avoid duplicates
	uniqueHooks := map[string]bool{}
	for _, m := range matched {
		alias, ok := hookImportAliases[m.Path]
		if !ok {
			continue
		}
		// Add reference to Before hook if specified
		if m.Before != "" {
			hookKey := m.Path + "." + m.Before
			if !uniqueHooks[hookKey] {
				uniqueHooks[hookKey] = true
				// var _ = _otel_hook_N.BeforeFunc
				hookRef := ast.SelectorExpr(ast.Ident(alias), m.Before)
				hookVar := ast.VarDecl("_", hookRef)
				decls = append(decls, hookVar)
			}
		}
		// Add reference to After hook if specified
		if m.After != "" {
			hookKey := m.Path + "." + m.After
			if !uniqueHooks[hookKey] {
				uniqueHooks[hookKey] = true
				// var _ = _otel_hook_N.AfterFunc
				hookRef := ast.SelectorExpr(ast.Ident(alias), m.After)
				hookVar := ast.VarDecl("_", hookRef)
				decls = append(decls, hookVar)
			}
		}
	}
	return decls
}

func buildOtelRuntimeAst(decls []dst.Decl) *dst.File {
	const comment = "// This file is generated by the opentelemetry-go-compile-instrumentation tool. DO NOT EDIT."
	return &dst.File{
		Name: ast.Ident("main"),
		Decs: dst.FileDecorations{
			NodeDecs: ast.LineComments(comment),
		},
		Decls: decls,
	}
}

// addDeps generates and writes otel.runtime.go with required imports and variable
// declarations for OpenTelemetry instrumentation based on matched rules.
func (sp *SetupPhase) addDeps(matched []*rule.InstRuleSet, packagePath string) error {
	rules := make([]*rule.InstFuncRule, 0)
	for _, m := range matched {
		funcRules := m.GetFuncRules()
		rules = append(rules, funcRules...)
	}
	if len(rules) == 0 {
		return nil
	}

	// Clear hook import aliases for fresh generation
	hookImportAliases = make(map[string]string)

	// Add required imports (including hook imports with named aliases)
	importDecls := genImportDecl(rules)
	// Generate the variable declarations that used by otel runtime
	varDecls := genVarDecl(rules)
	// Generate hook function references to ensure they are linked
	hookRefDecls := genHookRefDecl(rules)
	// Build the ast with all declarations
	allDecls := append(importDecls, varDecls...)
	allDecls = append(allDecls, hookRefDecls...)
	root := buildOtelRuntimeAst(allDecls)
	// Write the ast to file
	runtimeFilePath := filepath.Join(packagePath, OtelRuntimeFile)
	err := ast.WriteFile(runtimeFilePath, root)
	if err != nil {
		return err
	}
	sp.keepForDebug(runtimeFilePath)
	sp.Info("Created otel.runtime.go", "path", runtimeFilePath)
	return nil
}
